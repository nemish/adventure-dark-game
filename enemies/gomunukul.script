require "main.locomotion"
require "main.constants"

go.property("health", 2)

IDLE = "Idle"
MOVING = "Move"
ATTACK = "Attack"
SLEEP = "Sleep"
DAMAGED = "Damaged"
DEAD = "Dead"
go.property("Distance", 200)


function init(self)
    self.state = IDLE
    self.direction = -1
    self.t = 0
    self.pos = go.get_position()
    do_init(self)
end


STATES_CONFIG = {
    [ATTACK] = { 1 },
    [IDLE] = { 2 },
    [MOVING] = { 3 },
    [DAMAGED] = { 0.5 }
}


function update(self, dt)
    self.t = self.t + dt
    state_config = STATES_CONFIG[self.state]
    if self.state == DEAD then
        self.velocity.x = 0
    else
        if state_config and self.t > state_config[1] then
            self.t = 0
            if self.state == ATTACK then
                self.state = IDLE
            elseif self.state == DAMAGED then
                self.state = IDLE
            elseif self.state == MOVING then
                self.state = IDLE
            elseif self.state == IDLE then
                self.state = MOVING
            end
        elseif self.state == DEAD then
            self.velocity.x = 150 * self.damage_direction / (self.t + 1)
        elseif self.state == DAMAGED then
            -- local ratio = self.t < 1 and 1 or self.t
            self.velocity.x = 150 * self.damage_direction / (self.t + 1)
            -- sprite.set_hflip("#sprite", self.direction == 1)
        elseif self.state == ATTACK then
            self.velocity.x = 150 * self.direction
            sprite.set_hflip("#sprite", self.direction == 1)
        elseif self.state == MOVING then
            if self.velocity.x == 0 then
                self.direction = self.direction * -1
            end
            self.velocity.x = 100 * self.direction
            sprite.set_hflip("#sprite", self.direction == 1)
        elseif self.state == IDLE then
            self.velocity.x = 0
        end
        play_animation(self, hash(self.state))

        -- apply gravity if there's no ground contact and if we're not climbing a ladder
        if not self.ground_contact then
            self.velocity = self.velocity + gravityV3
        end
    end

    updatePos(self, dt)

    self.correction = vmath.vector3()
    self.ground_contact = false
    self.ladder_contact = false
end


function on_message(self, message_id, message, sender)
    if message_id == hash("animation_done") then
        if self.current_animation == hash("Die1") then
            go.delete()
        end
    elseif message_id == hash("trigger_response") then
        if (sender.fragment == hash("left_checker") or sender.fragment == hash("right_checker")) and message.enter and self.state ~= ATTACK then
            self.t = 0
            self.direction = sender.fragment == hash("right_checker") and 1 or -1
            self.state = ATTACK
        end
    elseif message_id == hash("damage") then
        self.t = 0
        self.health = self.health - (message.damage or 1)
        if self.health <= 0 then
            self.state = DEAD
            play_animation(self, hash("Die1"))
            msg.post(sender, "enemy_dead", { enemy_id = go.get_id() })
        else
            self.state = DAMAGED
            go.animate("#sprite", "tint", go.PLAYBACK_ONCE_PINGPONG, vmath.vector4(1, 0.3, 0.3, 1), go.EASING_LINEAR, 0.3)
        end
        self.damage_direction = message.direction
    elseif message_id == hash("contact_point_response") then
        if (message.group == GROUND_GROUP or message.group == CONSTRUCTION_GROUP or message.group == PLAYER_GROUP) then
            handle_geometry_contact(self, message.normal, message.distance)
        end
    end
end

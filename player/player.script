require "main.locomotion"
require "main.constants"
DIE_ANIM_HASH = hash("Die")
HURT_ANIM_HASH = hash("Hurt")
SLIDE_ANIM_HASH = hash("Slide")
RUN_ANIM_HASH = hash("Run")
JUMP_START_ANIM_HASH = hash("JumpStart")
IDLE_ANIM_HASH = hash("Idle")
FALL_DOWN_ANIM_HASH = hash("FallDown")
ATTACK_ANIM_HASH = hash("Attack")
THROW_ANIM_HASH = hash("Throw")
JUMP_LOOP_ANIM_HASH = hash("JumpLoop")

LEFT_ACTION_HASH = hash("left")
RIGHT_ACTION_HASH = hash("right")
UP_ACTION_HASH = hash("up")
DOWN_ACTION_HASH = hash("down")

GROUND_CHECKER_HASH = hash("ground_checker")
RIGHT_CHECKER_HASH = hash("right_checker")
LEFT_CHECKER_HASH = hash("left_checker")


go.property("health", 3)

function init(self)
    -- go.set("#sprite", "saturation", vmath.vector4(1, 0, 0, 0))
    -- go.set("#sprite1", "tint.w", 0.7)
	msg.post(".", "acquire_input_focus")
    self.direction = 1
    self.hurt = false
    self.dead = false
    self.finally_dead = false
    self.direction = 1
    self.hurt_direction = 1
    self.enemies = {
        [1] = nil,
        [-1] = nil
    }
    self.pos = go.get_position()

    do_init(self)

    msg.post("level1:/gui#gui", "set_health", { health = self.health })
    msg.post("level1:/camera#main_camera", "look_at", { position = self.pos, initial = true })
    msg.post("player_lighting", "look_at", { position = self.pos, initial = true  })
end


function final(self)
	msg.post(".", "release_input_focus")
end


local function throw_suriken(self)
    factory.create('#suriken_factory', nil, nil, { direction = self.direction })
end


function update(self, dt)
    -- if self.attacking then
    --     return

    if self.finally_dead then
        self.velocity.x = 0
    elseif self.dead then
        self.velocity.x = self.hurt_direction * 250
        play_animation(self, DIE_ANIM_HASH)
    elseif self.hurt then
        self.velocity.x = self.hurt_direction * 250
        play_animation(self, HURT_ANIM_HASH)
    elseif self.attacking then
        self.velocity.x = 0
    else
        if self.slide_start and os.clock() - self.slide_start < 0.2 then
            if math.abs(self.velocity.x) < 20 then
                self.slide_start = nil
            else
                play_animation(self, SLIDE_ANIM_HASH)
                multiplier = get_slide_direction(self)
                if multiplier == 0 or multiplier ~= self.slide_start_direction_int then
                    self.slide_start = nil
                end
                self.velocity.x = multiplier * 300
            end
        elseif self.slide_start then
            self.slide_start = nil
        end

        if not self.slide_start and not self.attacking and not self.hurt then
            if self.actions[LEFT_ACTION_HASH] then
                self.direction = -1
                self.velocity.x = -200
                sprite.set_hflip("#sprite", true)
                if self.land_contact then
                    play_animation(self, RUN_ANIM_HASH)
                end
            elseif self.actions[RIGHT_ACTION_HASH] then
                self.direction = 1
                self.velocity.x = 200
                sprite.set_hflip("#sprite", false)
                if self.land_contact then
                    play_animation(self, RUN_ANIM_HASH)
                end
            -- and clear it if we're not moving left/right
            else
                self.velocity.x = 0
            end
        end
    end


	-- are we in contact with a ladder?
	if self.ladder_contact then
		-- set vertical velocity if we are climbing up or down
		-- also set flag to indicate that we are climbing
		if self.actions[UP_ACTION_HASH] then
			self.velocity.y = 150
			self.ground_contact = true
			self.climbing = true
            play_animation(self, RUN_ANIM_HASH)
		elseif self.actions[DOWN_ACTION_HASH] then
			self.velocity.y = -150
			self.ground_contact = true
			self.climbing = true
            play_animation(self, JUMP_START_ANIM_HASH)
		elseif self.climbing then
			self.velocity.y = 0
		end
	else
		self.climbing = false
	end

    if not self.actions[LEFT_ACTION_HASH] and not self.actions[RIGHT_ACTION_HASH] and self.land_contact and not self.slide_start and not self.hurt and not self.attacking and not self.dead and not self.finally_dead then
        play_animation(self, IDLE_ANIM_HASH)
    end

	-- apply gravity if there's no ground contact and if we're not climbing a ladder
	if not self.ground_contact and not self.climbing then
		self.velocity = self.velocity + gravityV3
        if not self.dead and not self.finally_dead then
            if self.velocity.y < 0 then
                play_animation(self, FALL_DOWN_ANIM_HASH)
                self.hurt = false
            end
        end
	end

    updatePos(self, dt)

	-- reset volatile state
	self.correction = vmath.vector3()
	self.ground_contact = false
	self.ladder_contact = false

    if math.abs(self.velocity.x) < 25 and vert_moving_finished(self) and not self.attacking and not self.hurt and not self.dead and not self.finally_dead then
        play_animation(self, IDLE_ANIM_HASH)
    end

    msg.post("level1:/fg#parallax", "player_move", { velocity = self.velocity })
    msg.post("level1:/bg#parallax_bg", "player_move", { velocity = self.velocity })
    msg.post("level1:/camera#main_camera", "look_at", { position = self.pos })
    msg.post("player_lighting", "look_at", { position = self.pos })
end


function vert_moving_finished(self)
    return math.abs(self.velocity.y) < 25
end


function on_message(self, message_id, message, sender)
    if message_id == ANIMATION_DONE_HASH then
        if self.current_animation == DIE_ANIM_HASH then
            self.dead = false
            self.finally_dead = true
        elseif self.current_animation == HURT_ANIM_HASH then
            self.hurt = false
        elseif self.current_animation == ATTACK_ANIM_HASH or self.current_animation == THROW_ANIM_HASH then
            self.attacking = false
        elseif self.jump_start then
            play_animation(self, JUMP_LOOP_ANIM_HASH)
            self.jump_start = false
        end
    elseif message_id == TRIGGER_RESPONSE_HASH then
        if sender.fragment == GROUND_CHECKER_HASH and message.group == ELEVATOR_GROUP then
            self.movable_id_standing_on = message.other_id
            if message.enter then
                -- msg.post('.', 'set_parent', { parent_id = self.movable_id_standing_on })
                -- msg.post('.', 'set_parent', { keep_world_transform = 1, parent_id = self.movable_id_standing_on })
                msg.post(self.movable_id_standing_on, "activate")
            else
                -- msg.post('.', 'set_parent')
                -- msg.post('.', 'set_parent', { keep_world_transform = 1 })
                msg.post(self.movable_id_standing_on, "deactivate")
                self.movable_id_standing_on = nil
            end
        elseif sender.fragment == GROUND_CHECKER_HASH and message.enter then
            self.land_contact = true
            self.jump_start = false
            self.second_jump = false
        elseif sender.fragment == RIGHT_CHECKER_HASH or sender.fragment == LEFT_CHECKER_HASH then
            local enemy = message.enter and message.other_id or nil
            local sign = sender.fragment == RIGHT_CHECKER_HASH and 1 or -1
            self.enemies[sign] = enemy
            if self.attacking and sign == self.direction then
                msg.post(enemy, "damage", { direction = self.direction })
            end
        end
    elseif message_id == hash("enemy_dead") then
        for sign, enemy_id in pairs(self.enemies) do
            if enemy_id == message.enemy_id then
                self.enemies[sign] = nil
            end
        end
    elseif message_id == hash("elevator_stop") then
        if self.movable_id_standing_on then
            msg.post(self.movable_id_standing_on, "activate")
        end
	elseif message_id == CONTACT_POINT_RESPONSE_HASH then
		if (message.group == GROUND_GROUP or message.group == CONSTRUCTION_GROUP or message.group == ENEMY_GROUP) then
            handle_geometry_contact(self, message.normal, message.distance)
            if message.group == ENEMY_GROUP and not self.hurt then
                self.hurt_direction = (go.get_position(message.other_id).x - self.pos.x) > 0 and -1 or 1
                self.hurt = true
                self.velocity.y = 150
                self.health = self.health - 1
                msg.post("level1:/gui#gui", "set_health", { health = self.health })
                if self.health <= 0 then
                    self.dead = true
                end
            end
		elseif message.group == hash("ladder") then
			self.ladder_contact = true
		end
	end
end


function get_slide_direction(self)
    dir = 0
    if self.actions[LEFT_ACTION_HASH] then
        if self.ground_angle_y == 1 or self.ground_angle_x < 0 then
            dir = -1
        end
    elseif self.actions[RIGHT_ACTION_HASH] then
        if self.ground_angle_y == 1 or self.ground_angle_x >= 0 then
            dir = 1
        end
    end
    return dir
end

function on_input(self, action_id, action)

	if action_id then
        if self.hurt then
            if (action_id == LEFT_ACTION_HASH or action_id == RIGHT_ACTION_HASH) then
                -- set/clear action in map of all actions
                if action.pressed then
                    self.actions[action_id] = true
                    self.move_begin = true
                elseif action.released then
                    self.actions[action_id] = nil
                end
            end
            return
        end

		if action.pressed then
			self.actions[action_id] = true
            self.move_begin = true
		elseif action.released then
			self.actions[action_id] = nil
		end

        if action_id == hash("action") and action.pressed then
            if self.movable_id_standing_on then
                msg.post(self.movable_id_standing_on, "elevator_trigger", { height = 100 })
            end
        elseif action_id == DOWN_ACTION_HASH and action.pressed then
            if self.land_contact and self.ground_contact and not self.slide_start and not self.ladder_contact then
                self.slide_start_direction_int = get_slide_direction(self)

                if self.slide_start_direction_int then
                    play_animation(self, SLIDE_ANIM_HASH)
                    self.slide_start = os.clock()
                end
            end
        elseif action_id == hash("distance_attack") and action.pressed and self.land_contact then
            self.attacking = true
            play_animation(self, THROW_ANIM_HASH)
            throw_suriken(self)
        elseif action_id == ATTACK_ANIM_HASH and action.pressed and self.land_contact then
            self.attacking = true
            play_animation(self, ATTACK_ANIM_HASH)
            local enemyId = self.enemies[self.direction]
            if enemyId then
                msg.post(enemyId, "damage", { direction = self.direction })
            end
        -- jump
        elseif action_id == hash("jump") and action.pressed then
            if not self.land_contact and not self.second_jump then
                self.velocity.y = 800
                play_animation(self, hash("DoubleJump"))
                self.second_jump = true
            elseif self.land_contact then
                self.velocity.y = 500
                play_animation(self, JUMP_START_ANIM_HASH)
            end
            self.land_contact = false
            self.jump_start = true
            self.slide_start = false
		end
	end
end
